<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CONVERTTOBOOLEAN_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to convert a string value to xsd:Boolean value.

Arguments:
	input[0] : Source value.</value>
  </data>
  <data name="CONVERTTOBOOLEAN_NAME" xml:space="preserve">
    <value>ConvertToBoolean Functoid</value>
  </data>
  <data name="CONVERTTOBOOLEAN_TOOLTIP" xml:space="preserve">
    <value>Convert the input value to xsd:Boolean value</value>
  </data>
  <data name="EXECUTESQL_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to execute a parameterized SQL statement.

Arguments:
	input[0] : format string for the sql statement.
	input[1] : Connection string identifier name.
	input[2] : parameter {0} in the format string.
	...
	input[12]: parameter {10} in the format string.</value>
  </data>
  <data name="EXECUTESQL_NAME" xml:space="preserve">
    <value>ExecuteSql Functoid</value>
  </data>
  <data name="EXECUTESQL_TOOLTIP" xml:space="preserve">
    <value>This functoid can be used to execute a parameterized SQL statement.</value>
    <comment>_</comment>
  </data>
  <data name="FORMATDATETIME_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to read a given value as date and produce an output date value in a provided format.

Arguments:
	input[0] : Value of source Date to be formatted.
	input[1] : String used to specify the Date string format to read the input value. [ex: YYYY-mm-dd]
	input[2] : String used to specify the Date string format to produce output value. [ex: YYYY-mm-dd]
	input[3] : Label to describe what this is formatting.  Used to debug which instance of the functoid failed.</value>
  </data>
  <data name="FORMATDATETIME_NAME" xml:space="preserve">
    <value>FormatDateTime</value>
  </data>
  <data name="FORMATDATETIME_TOOLTIP" xml:space="preserve">
    <value>This functoid can be used to convert input value to a DateValue by providing input and output date formats.</value>
  </data>
  <data name="GENERATEGUID_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to return a newly generated GUID.

Arguments:
none</value>
  </data>
  <data name="GENERATEGUID_NAME" xml:space="preserve">
    <value>Generate GUID Functoid</value>
  </data>
  <data name="GENERATEGUID_TOOLTIP" xml:space="preserve">
    <value>Returns a newly generated GUID</value>
  </data>
  <data name="LOOKUPDBVALUEUSINGJOIN_DESCRIPTION" xml:space="preserve">
    <value>This functiod can be used to join two tables and lookup value from a database.

Arguments:

	input[0] : Column name of value to be returned
	input[1] : Schema name for the first table in a join query.
	input[2] : First table name in the join query.
	input[3] : First filter column name.
	input[4] : First Filter column value
	input[5] : Schemas name for the second table. 
	input[6] : Second table name in the join query.
	input[7] : Second filter column name.
	input[8] : Second Filter column value
	input[9] : Sql operator for example, like, =, !=, &lt;= ,&gt;= etc.
	input[10] : Connection string identifier name.</value>
  </data>
  <data name="LOOKUPDBVALUEUSINGJOIN_NAME" xml:space="preserve">
    <value>LookUpDbValueUsingJoin Functiod</value>
  </data>
  <data name="LOOKUPDBVALUEUSINGJOIN_TOOLTIP" xml:space="preserve">
    <value>This functoid can be used to join two table to lookup value from a database.</value>
  </data>
  <data name="LOOKUPDBVALUEWITHLIKEOPERATOR_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to lookup value from a Database table.

Arguments:
	input[0] : Column name of value to be returned.
	input[1] : Table schema name.
	input[2] : Table name.
	input[3] : Filter column name.
	input[4] : Filter column value.
	input[5] : Connection string identifier name.</value>
  </data>
  <data name="LOOKUPDBVALUEWITHLIKEOPERATOR_NAME" xml:space="preserve">
    <value>LookUpDbValueWithLikeOperator Functoid</value>
  </data>
  <data name="LOOKUPDBVALUEWITHLIKEOPERATOR_TOOLTIP" xml:space="preserve">
    <value>This functoid can be use to lookup a value from a Database table using LIKE operator.</value>
  </data>
  <data name="LOOKUPDBVALUE_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to lookup value from a Database table.

Arguments:
	input[0] : Column name of value to be returned.
	input[1] : Table schema name.
	input[2] : Table name.
	input[3] : Filter column name.
	input[4] : Filter column value.
	input[5] : Connection string identifier name.</value>
  </data>
  <data name="LOOKUPDBVALUE_NAME" xml:space="preserve">
    <value>LookupDbValue Functoid</value>
  </data>
  <data name="LOOKUPDBVALUE_TOOLTIP" xml:space="preserve">
    <value>This functoid can be use to lookup a value from a Database table.</value>
  </data>
  <data name="STATICVALUE_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to map as functoid output, the static value set in the params.

Arguments:
	input[0] : Value to be returned.</value>
  </data>
  <data name="STATICVALUE_NAME" xml:space="preserve">
    <value>Map Static Value Functoid</value>
  </data>
  <data name="STATICVALUE_TOOLTIP" xml:space="preserve">
    <value>Maps as functoid output, the static value set in params</value>
  </data>
  <data name="TRUNCATESTRING_DESCRIPTION" xml:space="preserve">
    <value>This functoid can be used to truncate a string to a maximum length.  This will only happen if the string currently exceeds the maximum lenght provided.

Arguments:
	input[0] : Source value.
	input[1] : Maximimum Length.</value>
  </data>
  <data name="TRUNCATESTRING_NAME" xml:space="preserve">
    <value>TruncateString Functoid</value>
  </data>
  <data name="TRUNCATESTRING_TOOLTIP" xml:space="preserve">
    <value>Truncates a string if necessary to achieve the maximum length allowed.</value>
  </data>
</root>