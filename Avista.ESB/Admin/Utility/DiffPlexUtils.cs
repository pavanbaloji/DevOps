using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using Microsoft.BizTalk.BaseFunctoids;
using Microsoft.XLANGs.BaseTypes;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Xsl;

namespace Avista.ESB.Admin.Utility
{
    /// <summary>
    /// DiffPlex
    /// </summary>
    public abstract class DiffPlexUtils
    {

        /// <summary>
        /// Detemines if the output of the map is equal to the expected XML file.
        /// Outputs using Side by Side
        /// </summary>
        /// <param name="assembly">The Test assembly</param>
        /// <param name="newXmlDocument">output generated by the map</param>
        /// <param name="expectedXmlFilePath">location of the referenced XML file ie: TestFiles.ProcessWorkCompletion.ToHost.Electric.MeterRemove.FormSubmittedMessage_To_WorkCanonical_ExpectedResult.xml</param>
        /// <param name="arguments">values passed into the XmlTemplate.Execute() method if the expected XML file is a template</param>
        /// <returns>true or false</returns>
        public bool IsXmlDifferent(Assembly assembly, XmlDocument newXmlDocument, string expectedXmlFilePath, object[] arguments = null, string[] ignoredLines = null)
        {

            XmlTemplate xmltemplate = new XmlTemplate();
            xmltemplate.LoadFromResource(assembly, expectedXmlFilePath);
            xmltemplate.Execute(arguments);

            XmlDocument expectedXmlDocument = xmltemplate.InstanceAsXmlDocument();

            string originalText = XElement.Parse(expectedXmlDocument.OuterXml).ToString();
            string newText = XElement.Parse(newXmlDocument.OuterXml).ToString();

            // Were there differences
            return SideBySideCompare(originalText, newText, ignoredLines: ignoredLines);
        }

        /// <summary>
        /// Compares 2 strings and outputs the differences in line mode
        /// </summary>
        /// <param name="originalText"></param>
        /// <param name="newText"></param>
        /// <returns>true or false</returns>
        public bool InlineCompare(string originalText, string newText)
        {
            Differ differ = new Differ();
            InlineDiffBuilder inlineDiffBuilder = new InlineDiffBuilder(differ);
            DiffPaneModel diffPaneModel = inlineDiffBuilder.BuildDiffModel(originalText, newText);

            foreach (DiffPiece diffPiece in diffPaneModel.Lines)
            {
                if (diffPiece.Type == ChangeType.Unchanged)
                {
                    Console.WriteLine(diffPiece.Text);
                }
                else
                {
                    Console.WriteLine("{0} - {1}", diffPiece.Type, diffPiece.Text);
                }

            }

            return (0 != diffPaneModel.Lines.Count(item => item.Type != ChangeType.Unchanged));
        }
        /// <summary>
        /// Compares 2 strings and outputs the differences in side by side mode
        /// </summary>
        /// <param name="originalText"></param>
        /// <param name="newText"></param>
        /// <returns>true or false</returns>
        public bool SideBySideCompare(string originalText, string newText, string[] ignoredLines = null)
        {
            if (ignoredLines == null)
            {
                ignoredLines = new string[] { };
            }
            Differ differ = new Differ();
            SideBySideDiffBuilder sideBySideDiffBuilder = new SideBySideDiffBuilder(differ);
            SideBySideDiffModel sideBySideModel = sideBySideDiffBuilder.BuildDiffModel(originalText, newText);

            int lineCounter = 0;
            foreach (DiffPiece diffPiece in sideBySideModel.NewText.Lines)
            {
                foreach (string ignoredLine in ignoredLines)
                {
                    if (diffPiece.Text != null && diffPiece.Text.Contains(ignoredLine))
                    {
                        diffPiece.Type = ChangeType.Unchanged;
                        break;
                    }
                }
                Console.WriteLine("{0}", WriteDiffPiece(diffPiece, sideBySideModel.OldText.Lines[lineCounter]));
                lineCounter++;
            }

            return (0 != sideBySideModel.NewText.Lines.Count(item => item.Type != ChangeType.Unchanged));
        }
        
        private static string WriteDiffPiece(DiffPiece newItem, DiffPiece expectedItem)
        {
            if (newItem.Type == ChangeType.Unchanged)
            {
                return newItem.Text;
            }
            else if (newItem.Type == ChangeType.Inserted)
            {
                return string.Format("Inserted - {0}", newItem.Text);
            }
            else if (newItem.Type == ChangeType.Deleted)
            {
                return string.Format("Deleted - {0}", newItem.Text);
            }
            else if (newItem.Type == ChangeType.Modified || newItem.Type == ChangeType.Imaginary)
            {
                return string.Format("Modified - {0} - Expected - {1}", newItem.Text, expectedItem.Text.Trim());
            }
            return "";
        }

    }
}
