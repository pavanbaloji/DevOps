using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using Microsoft.BizTalk.BaseFunctoids;
using Microsoft.XLANGs.BaseTypes;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Xsl;
using Microsoft.BizTalk.TestTools.Mapper;
using Microsoft.BizTalk.TestTools.Schema;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Avista.ESB.Admin.Utility;

namespace Avista.ESB.Testing
{
    /// <summary>
    /// This Helper class was implemented as part of the BTS2010 to BTS2013R2 upgrade effort.
    /// After upgrade, Maps containing references to external assemblies could no longer be debugged.
    /// This class was added to help provide reference the ExtensionObject (generated by Map validation) when executing the Map as part of a test.
    /// </summary>
    public class MapTestHelper : TestHelper
    {

        private static readonly string XmlNamespace1998AttrValue = @"http://www.w3.org/XML/1998/namespace";
        private static readonly string XmlNamespace1998ProperLocalName = @"xml";
        private static readonly string ExcludeResultPrefixesAttrName = @"exclude-result-prefixes";


        /// <summary>
        /// 
        /// </summary>
        /// <param name="map"></param>
        /// <param name="xml"></param>
        /// <param name="extObjects"></param>
        /// <returns></returns>
        public string ExecuteMap(TransformBase map, string xml, string extObjects = null)
        {
            string result = string.Empty;
            XslCompiledTransform transform = new XslCompiledTransform();
            XsltSettings setting = new XsltSettings(false, true);
            var xmlContent = map.XmlContent;
            if (!String.IsNullOrWhiteSpace(xmlContent))
            {
                xmlContent = FixSpecialNamespaceLocalName(xmlContent);

                transform.Load(XmlReader.Create(new StringReader(xmlContent)), setting, new XmlUrlResolver());

                using (StringWriter writer = new StringWriter())
                {
                    transform.Transform(XmlReader.Create(new StringReader(xml)),
                        GetExtensionObjects(extObjects), XmlWriter.Create(writer));
                    result = writer.ToString();
                }
            }
            return result;
        }

        private static string FixSpecialNamespaceLocalName(string xmlContent)
        {
            if (!xmlContent.Contains(XmlNamespace1998AttrValue))
            {
                return xmlContent;
            }

            XmlDocument doc = new XmlDocument();
            string nsLocalName = String.Empty;
            doc.LoadXml(xmlContent);
            if (doc.DocumentElement != null)
            {
                // find existing LocalName
                foreach (XmlAttribute attr in doc.DocumentElement.Attributes)
                {
                    if (String.Equals(attr.Value, XmlNamespace1998AttrValue))
                    {
                        nsLocalName = attr.LocalName;
                        break;
                    }
                }
                // if found, make various replacements
                if (!String.IsNullOrWhiteSpace(nsLocalName))
                {
                    // root attr and nodes
                    xmlContent = xmlContent.Replace("xmlns:" + nsLocalName, "xmlns:" + XmlNamespace1998ProperLocalName);
                    xmlContent = xmlContent.Replace(nsLocalName + ":", XmlNamespace1998ProperLocalName + ":");

                    // process the "exclude result prefixes" attr
                    string attrVal = doc.DocumentElement.Attributes[ExcludeResultPrefixesAttrName].Value;
                    if (!String.IsNullOrWhiteSpace(attrVal))
                    {
                        var attrToReplace = String.Format("{0}=\"{1}\"", ExcludeResultPrefixesAttrName, attrVal);
                        var attrReplacement = String.Format("{0}=\"{1}\"", ExcludeResultPrefixesAttrName,
                            attrVal.Replace(nsLocalName, XmlNamespace1998ProperLocalName));
                        xmlContent = xmlContent.Replace(attrToReplace, attrReplacement);
                    }
                }
            }
            return xmlContent;
        }


        /// <summary>
        /// GetExtensionObjects
        /// </summary>
        /// <param name="extObjects"></param>
        /// <returns></returns>
        private XsltArgumentList GetExtensionObjects(string extObjects)
        {
            XsltArgumentList arguments = new XsltArgumentList();
            if (extObjects == null)
                return arguments;

            XDocument extObjectsXDoc = XDocument.Parse(extObjects);
            foreach (XElement node in extObjectsXDoc.Descendants("ExtensionObject"))
            {
                string assembly_qualified_name = String.Format("{0}, {1}", node.Attribute("ClassName").Value, node.Attribute("AssemblyName").Value);
                object extension_object = Activator.CreateInstance(Type.GetType(assembly_qualified_name));
                arguments.AddExtensionObject(node.Attribute("Namespace").Value, extension_object);
            }
            return arguments;
        }

        /// <summary>
        /// GetFunctoidExtensionObject
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ns"></param>
        /// <returns></returns>
        public string GetFunctoidExtensionObject<T>(string ns = "NS0") where T : BaseFunctoid
        {
            Type functoidType = typeof(T);

            return
                string.Format(
                    @"<ExtensionObject Namespace=""http://schemas.microsoft.com/BizTalk/2003/Script{0}"" AssemblyName=""{1}"" ClassName=""{2}"" />",
                    ns, functoidType.Assembly, functoidType.FullName);
        }

        /// <summary>
        /// ExecuteMapTest
        /// </summary>
        /// <typeparam name="Map"></typeparam>
        /// <param name="inputMessage"></param>
        /// <param name="expectedResultReference"></param>
        /// <param name="targetSchema"></param>
        /// <param name="validateXmlOutput"></param>
        /// <param name="extObjects"></param>
        /// <param name="testContext"></param>
        /// <returns></returns>
        public string ExecuteMapTest<Map>(Assembly assembly, string inputMessage, string expectedResultReference, TestableSchemaBase targetSchema = null, bool validateXmlOutput = true, string extObjects = null, TestContext testContext = null, object[] expectedResultArguments = null, string[] ignoredLines = null)
                                            where Map : TestableMapBase, new()
        {
            var mapTestHelper = new MapTestHelper();
            TestableMapBase map = new Map();

            // Execute the map and load the output.
            string result = mapTestHelper.ExecuteMap(map, inputMessage, extObjects);

            XmlDocument output = new XmlDocument();
            output.LoadXml(result);

            if (testContext != null)
            {
                testContext.WriteLine("{0}", output.OuterXml);
            }

            if (validateXmlOutput)
            {
                // Perform XML Schema validation on the output.
                XmlValidationResult xmlValidationResult = new XmlValidationResult(targetSchema, output);
                Assert.IsTrue(xmlValidationResult.IsValid, map.ToString() + " test failed. The output file was not valid. " + xmlValidationResult.Message);
            }

            Assert.IsFalse(mapTestHelper.IsXmlDifferent(assembly, output, expectedResultReference, arguments: expectedResultArguments, ignoredLines: ignoredLines), "Differences exist.");

            return result;
        }
    }
}
